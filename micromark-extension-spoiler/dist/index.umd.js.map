{"version":3,"file":"index.umd.js","sources":["../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../src/html.ts","../src/index.ts"],"sourcesContent":["export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import { Token } from 'micromark/dist/shared-types';\n\nexport type SpoilerHtmlOptions = {};\n\n/**\n * Converts a token stream produced by the syntax extension\n * directly to HTML, with no intermediate AST.\n */\nexport function spoilerHtml(this: any, opts: SpoilerHtmlOptions = {}) {\n  function enterSpoiler(this: any): void {}\n\n  function exitSpoiler(this: any, token: Token): void {\n    this.tag(`<span class=\"spoiler\">`);\n    this.raw(this.sliceSerialize(token));\n    this.tag('</span>');\n  }\n\n  return {\n    enter: {\n      spoilerText: enterSpoiler,\n    },\n    exit: {\n      spoilerText: exitSpoiler,\n    },\n  };\n}\n","import { State, Effects, Resolve, Tokenizer, Event, Token } from 'micromark/dist/shared-types';\nimport * as MM from 'micromark/dist/shared-types';\nimport { CodeAsKey } from 'micromark/lib/shared-types';\n\nexport { spoilerHtml } from './html';\n\n/**\n * As of (2021/05/05), the typings exported by `remark` do not\n * accurately reflect their usage, so we patch them here.\n *\n * When exporting functions, we need to be careful to cast back to\n * the built-in types, to be compatible with the current typings for remark.\n */\n\ntype SyntaxExtensionHook = { [key: number]: Construct | Construct[]; null?: Construct | Construct[] };\n\ninterface SyntaxExtension {\n  document?: SyntaxExtensionHook;\n  contentInitial?: SyntaxExtensionHook;\n  flowInitial?: SyntaxExtensionHook;\n  flow?: SyntaxExtensionHook;\n  string?: SyntaxExtensionHook;\n  text?: SyntaxExtensionHook;\n}\n\ntype Tokenize = (this: Tokenizer, effects: Effects, ok: State, nok: State) => State;\n\ninterface Construct {\n  name?: string;\n  tokenize: Tokenize;\n  partial?: boolean;\n  resolve?: Resolve;\n  resolveTo?: Resolve;\n  resolveAll?: Resolve;\n  concrete?: boolean;\n  interruptible?: boolean;\n  lazy?: boolean;\n  // typically extensions will want to get precedence over existing markdown\n  // constructs. after can be used to invert that\n  // https://github.com/micromark/micromark/discussions/54#discussioncomment-693151\n  add?: 'after' | 'before';\n}\n\ninterface TypeSafeEffects<T extends string> {\n  /**\n   * Enter and exit define where tokens start and end\n   */\n  enter: (type: T) => Token;\n\n  /**\n   * Enter and exit define where tokens start and end\n   */\n  exit: (type: T) => Token;\n\n  /**\n   * Consume deals with a character, and moves to the next\n   */\n  consume: (code: number) => void;\n\n  /**\n   * Attempt deals with several values, and tries to parse according to those values.\n   * If a value resulted in `ok`, it worked, the tokens that were made are used,\n   * and `returnState` is switched to.\n   * If the result is `nok`, the attempt failed,\n   * so we revert to the original state, and `bogusState` is used.\n   */\n  attempt: (\n    constructInfo: Construct | Construct[] | Record<CodeAsKey, Construct | Construct[]>,\n    returnState: State,\n    bogusState?: State\n  ) => (code: number | null) => void;\n\n  /**\n   * Interrupt is used for stuff right after a line of content.\n   */\n  interrupt: (\n    constructInfo: Construct | Construct[] | Record<CodeAsKey, Construct | Construct[]>,\n    ok: MM.Okay,\n    nok?: MM.NotOkay\n  ) => (code: number | null) => void;\n\n  check: (\n    constructInfo: Construct | Construct[] | Record<CodeAsKey, Construct | Construct[]>,\n    ok: MM.Okay,\n    nok?: MM.NotOkay\n  ) => (code: number | null) => void;\n\n  /**\n   * Lazy is used for lines that were not properly preceded by the container.\n   */\n  lazy: (\n    constructInfo: Construct | Construct[] | Record<CodeAsKey, Construct | Construct[]>,\n    ok: MM.Okay,\n    nok?: MM.NotOkay\n  ) => void;\n}\n\nexport interface SpoilerSyntaxOptions {}\n\n/**\n * Adds support for Discord-style spoilers to `micromark`.\n */\nexport const spoilerSyntax = function (options?: Partial<SpoilerSyntaxOptions>): SyntaxExtension {\n  return {\n    text: {\n      [124]: { tokenize: spoilerTokenize },\n    } as unknown as SyntaxExtension['text'],\n  };\n} as (options: Partial<SpoilerSyntaxOptions>) => MM.SyntaxExtension;\n\nconst lookaheadConstruct = {\n  partial: true,\n  /** If the next two characters are `||`, run `ok`, else `nok`. */\n  tokenize(effects: Effects, ok: State, nok: State): State {\n    return start;\n\n    function start(code: number) {\n      // match first symbol `|`\n      if (code !== 124) {\n        return nok(code);\n      }\n      effects.consume(code);\n      return lookaheadAt;\n    }\n\n    function lookaheadAt(code: number) {\n      // match second symbol `|`\n      if (code !== 124) {\n        return nok(code);\n      }\n      effects.consume(code);\n      return ok(code);\n    }\n  },\n};\n\nconst enum SpoilerToken {\n  spoiler = 'spoiler',\n  spoilerMarker = 'spoilerMarker',\n  spoilerText = 'spoilerText',\n}\n\n/**\n * Entry-point for the spoiler tokenizer.\n */\nconst spoilerTokenize: Tokenize = function (\n  this: Tokenizer,\n  effects: Effects | TypeSafeEffects<SpoilerToken>,\n  ok: State,\n  nok: State\n): State {\n  // typos in strings manually passed to enter() / exit() have been\n  // a source of bugs, so let TypeScript error-check for us\n  effects = effects as unknown as TypeSafeEffects<SpoilerToken>;\n\n  return firstSpoilerStart;\n\n  function firstSpoilerStart(code: number): State | void {\n    // match first starting '|'\n    if (code === 124) {\n      effects.enter(SpoilerToken.spoiler);\n      effects.enter(SpoilerToken.spoilerMarker);\n      effects.consume(code);\n      return secondSpoilerStart;\n    }\n    // invalid starting character\n    else {\n      return nok(code);\n    }\n  }\n\n  function secondSpoilerStart(code: number): State | void {\n    // match second starting '|'\n    if (code === 124) {\n      effects.consume(code);\n      effects.exit(SpoilerToken.spoilerMarker);\n      effects.enter(SpoilerToken.spoilerText);\n      return consumeSpoilerText;\n    }\n    // invalid character\n    else {\n      return nok(code);\n    }\n  }\n\n  function consumeSpoilerText(code: number): State | void {\n    // match first ending '|'\n    if (code === 124) {\n      return effects.check(lookaheadConstruct as any, firstSpoilerEnd, consumeSpoilerText)(code);\n    }\n    if (code === null) {\n      return nok(code);\n    }\n\n    // otherwise, continue consuming characters\n    effects.consume(code);\n    return consumeSpoilerText;\n  }\n\n  function firstSpoilerEnd(code: number): State | void {\n    // match first ending '|'\n    if (code === 124) {\n      effects.exit(SpoilerToken.spoilerText);\n      effects.enter(SpoilerToken.spoilerMarker);\n      effects.consume(code);\n      return secondSpoilerEnd;\n    }\n    // invalid character\n    else {\n      return nok(code);\n    }\n  }\n\n  function secondSpoilerEnd(code: number): State | void {\n    // match second ending '|'\n    if (code === 124) {\n      effects.consume(code);\n      effects.exit(SpoilerToken.spoilerMarker);\n      effects.exit(SpoilerToken.spoiler);\n      return ok;\n    }\n    // invalid character\n    else {\n      return nok(code);\n    }\n  }\n};\n"],"names":[],"mappings":"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"}